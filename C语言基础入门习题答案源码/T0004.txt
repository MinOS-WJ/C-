题目一：答案：错误 ,
原因：char * p =“Hello” 定义了一个指向字符串的指针变量 p，并将其初始化为字符串 “Hello” 的地址。所以指针变量的值为字符串的地址
题目二：答案：6,6：
原因：执行*p++ += 100语句之后，数组变成{104，5，6，7，8}，p指针指向第个二元素：5，重点是考察的是变参函数printf，printf的参数入栈是从右到左执行的，所以先执行∗ *∗(++p)输出6，再 执行∗ *∗p输出6，输出的是同一个元素。此题答案之前出现分歧，可能是运行环境不一致导致的。
题目三：答案：A：
原因：在二维数组中，∗ *∗(a+1)表示第二列首元素地址，这里是7；(a[1]+1)表示第二列第二个元素的地址，这里应该是元素9的地址；**(a +1)表示第二列首元素求值，这里是7，+2得到的是9；a和a[0]其实是一样的。
题目四：答案：2,5：
原因：因为&a是整个数组a的地址，所以&a+1指向的是整个数组a后面的一个位置（跨越了整个数组），也就是ptr指向的是数组a之外的下一个位置。而由于数组a是连续存储的，所以这个位置恰好是数组a最后一个元素的下一个位置。因此∗ *∗(ptr-1)的值就是数组a中最后一个元素的值，即5
题目五：答案：运行结果：运行无误，但打印乱码：
原因：getMemory(void)中的p[]为函数内的局部自动变量，在函数返回后，内存已经被释放。如果一步步调试，会发现执行str=getMenory();后str不再是NULL了，但是str的内容并不是hello world，而是垃圾数据。
题目六：答案：A：
原因：主要考察递归思想，此题答案来自牛客网码友，鸣谢！
题目七：答案：运行会报错，：
原因：这种形式的字符串存储在常量区。常量区 字符串只有读取权限，没有写入权限，这就导致了字符数组 在定义后可读取和修改每个字符而 第二种形式（字符串常量） 一旦定义后便不可修改，对它的赋值都是错误的（可整体赋值），这种形式可修改：
char str[] = “hello world”;
char *pstr = str;
*str = ‘a’;
题目八：答案：赋值方式错误：
原因：字符数组 只有在定义时才可一次性赋值，一旦定义完就只能一个个赋值。这样写正确：str[0] = ‘a’; str[1] = ‘b’; str[2] = ‘c’;
题目九：答案：
12
o
world!
原因：字符数组是一个数组，关于指针和数组的规则同样也适用于字符数组.故输出字符串也可以用：∗ *∗(pstr+i)、pstr[i]、*(str+i) 、str[i]进行输出
题目十：答案：D：
原因：char* p = “abcdefgh”，每个字符占1个字节，那么总共是8个字节，此时p指向’a’。如果是p++，那么p将指向’b’。打印p会得到"bcdefgh"。 long* q = (long*)p 将p强制转换为long*类型，也就是用long类型去解释存储了"abcdefgh"的这一段内存，此时q指向’a’，由于long类型是4个字节，那么q++移动4个字节，q将指向’e’，打印q将得到"efgh"。
题目十一：答案：D：
原因，这里定义的是一个指针数组，本质是一个数组，数组元素为指针
题目十二：答案：D：
原因：以上语句定义了一个指针数组 s。本质是一个数组，数组元素为字符串指针，而数组名是指向第一个元素的常量指针，因此 s 是指向指针的指针，所以函数 fun 的形参定义是 char **。fun(s) 将指针 s 的值传递给形参 p，所以 p = s，因此for(i=0;i<4;i + + )printf(“% s”,p[i]);中 printf(“% s”,p[i]) 等价于 printf(“% s”,s[i])。注意， s[i] 中存储的不是字符串，而是字符类型的指针，但 printf 会输出 s[i] 存储的指针指向的字符串。所以最后输出为 D。
